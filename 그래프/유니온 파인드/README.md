### Union & Find  
  

**ì—¬ëŸ¬ ê°œì˜ ë…¸ë“œê°€ ì¡´ì¬í•  ë•Œ ë‘ ê°œì˜ ë…¸ë“œë¥¼ ì„ íƒí•´ì„œ í˜„ì¬ ë…¸ë“œê°€ ì„œë¡œ ê°™ì€ ê·¸ë˜í”„ì— ì†í•˜ëŠ”ì§€ íŒë³„í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜**  
ì„œë¡œì†Œ ì§‘í•©(Disjoint Sets)ë¼ê³ ë„ ë¶€ë¥´ë©° ì£¼ë¡œ ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜ì—ì„œ ì‚¬ìš©ëœë‹¤.
  
> Find : ì–´ë–¤ ì›ì†Œê°€ ì£¼ì–´ì¡Œì„ ë•Œ í•´ë‹¹ ì›ì†Œê°€ ì†í•œ ì§‘í•©ì„ ë°˜í™˜í•œë‹¤.  
	 ì¼ë°˜ì ìœ¼ë¡œ ì–´ë–¤ ì›ì†Œê°€ ì†í•œ ì§‘í•©ì„ ëŒ€í‘œí•˜ëŠ” ì›ì†Œë¥¼ ë°˜í™˜í•˜ì—¬ ê°™ì€ ì§‘í•©ì„ì„ íŒë‹¨ 
>
> Union : ë‘ ê°œì˜ ì§‘í•©ì„ í•˜ë‚˜ì˜ ì§‘í•©ìœ¼ë¡œ í•©ì¹œë‹¤. 
>
  
  
- ì‹œê°„ ë³µì¡ë„ : O(logN) í‰ê· ì ìœ¼ë¡œ íŠ¸ë¦¬ì˜ ë†’ì´ë§Œí¼ 
  
  
<details>
<summary> ğŸ” êµ¬í˜„  </summary>
	
**1. ì§‘í•© ìƒì„± ë° ì´ˆê¸°í™”** 
**parent[] ë°°ì—´ë¡œ ê° ë…¸ë“œê°€ ì–´ë–¤ ë¶€ëª¨ ë…¸ë“œ ì•„ë˜ì— ìˆëŠ”ì§€ ê·¸ë˜í”„ë¡œ ë§Œë“ ë‹¤**  
```
 	int[] parent = new int[5];
        for (int i = 0; i < 5; i++) {
            parent[i] = i;
        }
```
ì´ˆê¸° ë°°ì—´ì€ ìê¸° ìì‹ ì˜ ë…¸ë“œ ë²ˆí˜¸ë¥¼ ê°€ì§„ë‹¤(ë…¸ë“œë§ˆë‹¤ ë¶„ë¦¬ë˜ì–´ìˆìŒ)  
  
  
**2. Find**
**íŠ¹ì • ìš”ì†Œê°€ ì–´ëŠ ì§‘í•©ì— ì†í•´ìˆëŠ”ì§€ ì°¾ëŠ”ë‹¤**  
```
	public int find(int x) {
    	    if(x == parent[x]){
	        return x;
	    }
    	    else{
	        return parent[x] = find(parent[x]);
	    }
	}
```
ê°€ì¥ ìƒìœ„ ë…¸ë“œ xì˜ ê²½ìš° x == parent[x] ê´€ê³„ê°€ ì„±ë¦½í•œë‹¤.  
ì¬ê·€ë¥¼ í†µí•´ ì§‘í•©ì˜ ê°€ì¥ ìƒìœ„ ë…¸ë“œë¥¼ ì°¾ì•„ return  
  
  
**3. Union**
**xì™€ yê°€ í¬í•¨ëœ ì§‘í•©ì„ í•©ì¹œë‹¤.**  
```
	public void union(int x, int y) {
    	    x = find(x);
    	    y = find(y);
    	    if(x!=y) { //ì´ë¯¸ ê°™ì€ ì§‘í•©ì´ë¼ë©´ ê°±ì‹ ì´ í•„ìš”ì—†ìŒ 
    	        if(x < y) {
		    parent[y] = x;
		}
    	        else {
		    parent[x] = y;
		}
    	    }
	}
```
ì§‘í•©ì˜ ê°€ì¥ ìƒìœ„ ë…¸ë“œë¥¼ í†µí•´ ê°™ì€ ì§‘í•©ì„ì„ í‘œí˜„  
  

**4. ë‘ ìš”ì†Œê°€ ê°™ì€ ì§‘í•©ì¸ì§€ íŒë‹¨**
**ê°™ì€ parent[] ê°’ì„ ê°–ëŠ”ì§€ í™•ì¸í•œë‹¤.**
```
	public boolean isSameParent(int x, int y) {
	    x = find(x);
	    y = find(y);
	    if(x == y){
		return true;
	    }
	    else{
		return false;
	    }
 	}
```
findë¥¼ í†µí•´ ì¬ê·€ë¡œ ê°™ì€ ë¶€ëª¨ë¥¼ ê°–ê³  ìˆëŠ”ì§€ íŒë‹¨  
   
---

<details>
<summary> ğŸŒŸì˜ˆì‹œ </summary>
	
**1. ì´ˆê¸°í™”**
	
```
 	int[] parent = new int[3];
        for (int i = 1; i < 4; i++) {
            parent[i] = i;
        }
```
		
![image](https://github.com/hanseul9/algorithm/assets/102939057/84a69ab2-d998-4dfc-83e2-29ab51c0237b)

**2. Union**
```
	union(2, 3)
	...
	static void union(int x, int y) {
    	    x = find(x);
    	    y = find(y);
    	    if(x!=y) { //ì´ë¯¸ ê°™ì€ ì§‘í•©ì´ë¼ë©´ ê°±ì‹ ì´ í•„ìš”ì—†ìŒ 
    	        if(x < y) {
		    parent[y] = x;
		}
    	        else {
		    parent[x] = y;
		}
    	    }
	}
```
ë¨¼ì € find(2), find(3) -> ê°ê° 2ì™€ 3ë¦¬í„´.  
ë‘˜ì€ ë‹¤ë¥¸ ì§‘í•©ì´ë¯€ë¡œ ì—°ê²°  
ë‘ ì§‘í•©ì„ ì—°ê²° -> parent[3] = 2;
![image](https://github.com/hanseul9/algorithm/assets/102939057/338a4f82-caa8-44cd-ab27-b58e2a2860a2)

**3. ê°™ì€ ì§‘í•©ì¸ì§€ íŒë‹¨í•˜ê¸°** 
```
	boolean a = isSameParent(1,2);
	boolean b = isSameParent(2,3);
	....
	public boolean isSameParent(int x, int y) {
	    x = find(x);
	    y = find(y);
	    if(x == y){
		return true;
	    }
	    else{
		return false;
	    }
 	}
```
í˜„ì¬ ìƒí™©ì€  
parent[1] = 1;  
parent[2] = 2;  
parent[3] = 2;  
ì´ë¯€ë¡œ 1ì™€ 2ì˜ ë¶€ëª¨ê°€ ë‹¤ë¦„ << a == false
2 ì™€ 3 ì€ ê°™ì€ ë¶€ëª¨ << b == true 



</details>

---

</details>
  
+) ê°™ì€ ì§‘í•© ë‚´ì—ì„œ ë‘ ë…¸ë“œë¥¼ ì—°ê²°í•˜ë©´ ì‚¬ì´í´ì´ ìƒê¸°ê¸° ë•Œë¬¸ì— ì‚¬ì´í´ ìƒì„± ìœ ë¬´ë¥¼ íŒë‹¨í•˜ê¸° ìœ„í•´ì„œ ì‚¬ìš©ë˜ê¸°ë„ í•œë‹¤
