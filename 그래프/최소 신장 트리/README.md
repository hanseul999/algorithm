## 최소 신장 트리  
  
  
#### 신장 트리(Spanning Tree)  
  - 무방향 그래프 G(V,E)에서 E에 속한 간선들로 사이클을 포함하지 않으면서 모든 정점 V를 연결한 부분 그래프를 신장 트리(Spanning Tree)라 한다.  
<img src="https://github.com/hanseul9/algorithm/assets/102939057/fa832427-3546-4bbe-8936-77d4336e29b3" width="400">
  
  - 그래프에서 신장 트리는 여러 형태로 존재할 수 있다.
  - 신장트리는 n개의 정점을 갖는 그래프에서 신장 트리에 속하는 간선의 수는 n-1개이며 사이클을 이루지 않는다는 특징이 있다.
  
#### 최소 신장 트리 : Minimum Spanning Tree(MST)  
  - 최소 비용 신장 트리(최소 신장 트리) 란 무방향 그래프의 간선들에 가중치가 주어진 경우,  
    여러 신장 트리 중에 **간선들의 가중치 합이 최소**인 신장 트리를 의미한다.
  
  
---
#### 크루스칼(Kruskal)
  - 최소 신장 트리를 구하는 알고리즘 중 하나로 그리디 알고리즘(결정의 순간마다 최선의 결정)을 통해  
    모든 정점을 최소 비용으로 연결하여 최소 신장 트리를 구한다. (간선 중심)
  - 모든 간선을 가중치 기준으로 오름차순으로 정렬한 뒤 간선들을 순서대로 모든 정점이 연결될 때까지 연결하는 것이 핵심
  - 유니온 파인드를 통해 구현 가능
    - 유니온 파인드는 상수 시간 복잡도를 가지며 간선을 정렬해야 하기 때문에 간선의 수가 적을 때 프림 알고리즘보다 유리
  
**🌱동작 방식**  
초기 상태로 정점은 서로 연결되어 있지 않다. 간선을 하나씩 추가하면서 MST를 만든다.
> 1. 그래프의 간선들을 가중치 기준 오름차순으로 정렬한다.
>    
> 2. 간선을 그래프에 포함 했을 때, MST에 사이클이 생기지 않으면 추가한다.
>    해당 과정에서 유니온 파인드 이용. 두 정점을 이을 때 같은 부모 노드를 가진다면 MST에 추가하지 않는다(사이클 발생 방지 - 사이클이 생기면 트리가 아닌 그래프가 됨)
> 
> 3. 만약 간선의 두 정점 a,b가 이미 연결되어 있다면 스킵한다.
>
> 4. 위의 과정을 반복하여 최소 비용의 간선들만 이용하여 모든 정점을 연결한다. 

+) 사이클을 피하면서 간선을 연결하다보면 (간선은 가중치를 기준으로 오름차순 정렬돼있으므로) 모든 정점이 연결되면 자연스레 최소 신장 트리가 만들어짐.  
++) 오름차순으로 정렬된 간선을 순서대로 연결한다는 점(제일 작은 가중치를 고르게됨)에서 그리디 알고리즘
  
---
  
#### 프림(Prim)  
  - 마찬가지로 최소 신장 트리를 구하는 알고리즘 중 하나로  
    임의의 시작점에서 현재까지 연결된 정점들에서 연결되지 않은 정점들에 대해 가장 가중치가 작은 정점을 연결하는 정점 선택 기반으로 동작 (정점 중심)
  -  트리 집합을 단계적으로 확장하는 것이 핵심
  -  Priority Queue를 이용한 최소 힙으로 구현 가능  
    - 이 경우 시간 복잡도는 O(ElogV) : 정점의 수가 적을 때 크루스칼보다 유리   
  
**🌱동작 방식**  
초기 상태로 정점은 서로 연결되어 있지 않다. 간선을 하나씩 추가하면서 MST를 만든다.
우선 순위 큐에는 (정점, 가중치) 형식으로 저장되며, 첫 시작은 (시작 정점, 0)으로 넣는다.
> 1. 우선 순위 큐에서 하나를 꺼낸다.
>    
> 2. 꺼낸 정점 V가 이미 MST에 포함되어있다면 1️⃣로 돌아간다
>    
> 3. MST에 포함돼있지 않다면 v와 연결된 간선을 모두 살핀다. 연결되고 방문하지 않은 (정점, 가중치)를 모두 우선순위 큐에 추가 
> 
> 4. 최소 힙이 빌 때까지 3️⃣과정 반복 
  
  
+) 주의 : PriorityQueue에 사용자 정의 클래스 객체를 넣을라면  
     해당 클래스는 Comparable 인터페이스를 구현하여 compareTo()를 오버라이딩해줘야함(비교 방법을 명시해줘야함)


